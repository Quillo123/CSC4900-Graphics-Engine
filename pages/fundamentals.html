<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>CSC4900 Graphics Engine</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css"
        integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
    <link rel="stylesheet" href="stylesheets/default.css">
    <link rel="stylesheet" href="stylesheets/index.css">
</head>

<body class="background bg-dark text-white" style="padding-bottom: 50%;">
    <nav class="navbar navbar-expand-lg navbar-dark bg-secondary">
        <a class="navbar-brand" href="index.html">Graphics API</a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav"
            aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="navbarNav">
            <ul class="navbar-nav">
                <li class="nav-item active">
                    <a class="nav-link" href="./index.html">Home</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="./experience.html">My Experience</a>
                </li>
                <li class="nav-item dropdown">
                    <a class="nav-link dropdown-toggle" href="#" id="navbarBooks" role="button" data-toggle="dropdown"
                        aria-haspopup="true" aria-expanded="false">
                        The Project
                    </a>
                    <div class="dropdown-menu" aria-labelledby="navbarBooks">
                        <a class="dropdown-item" href="./fundamentals.html">Fundamentals</a>
                        <a class="dropdown-item" href="./installation.html">Installation and Setup</a>
                        <a class="dropdown-item" href="./documentation.html">Documentation</a>
                        <a class="dropdown-item" href="./sample.html">Sample Application</a>
                    </div>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="./references.html">References</a>
                </li>
            </ul>
        </div>
    </nav>


    <!-- Title ******************************************************************************** -->
    <div class="container-fluid text-center">
        <h1 class="display-2 pt-4 mb-5">
            Fundamentals of Graphics Programming
        </h1>
    </div>

    <!-- Linear Algebra ******************************************************************************** -->
    <div class="container-fluid w-75 pl-4">
        <button class="display-4 bg-dark text-white border-0" data-toggle="collapse" href="#LinearAlgebra" role="button"
            aria-expanded="false" aria-controls="collapseExample">
            Prerequisite
        </button>
        <div class="collapse" id="LinearAlgebra">
            <h3 class="display-5 pt-3 pl-3">
                Linear Algebra
            </h3>
            <p class="lead pl-4 p-1">
                There are a lot of technical elements to graphics programming, especially when it comes to 3D Math.
                Before getting into the details, ensure that you have a basic understanding of linear algebra, and
                working with
                vectors, matrices, and matrix transformation. You don't need to know exactly how the underlying math
                works, but
                just know the basics of how to use it. I'm going to assume for the sake of space that you have a basic
                understanding
                of these topics, though I will go over some topics in future sections.
            </p>

            <h3 class="display-5 pt-3 pl-3">
                Programming 
            </h3>
            <p class="lead pl-4 p-1">
                TODO
            </p>
        </div>
        <hr class="my-4 border-white">
    </div>
    <!-- 3D Mesh ******************************************************************************** -->
    <div class="container-fluid w-75 pl-4">
        <button class="display-4 bg-dark text-white border-0" data-toggle="collapse" href="#Mesh" role="button"
            aria-expanded="false" aria-controls="collapseExample">
            3D Meshes
        </button>
        <div class="collapse" id="Mesh">
            <p class="lead pl-4 p-1">
                When rendering a 3D object, we create what are known as meshes. Meshes are a collection of vertices
                (3D positions) that we wrap into triangles.
            </p>
            <p class="lead pl-4 p-1">Here's a representation of a square mesh, also known as a quad:</p>
            <img src="./images/3D Mesh.png" class="rounded ml-5 d-block" width="500" height="500">
            <p class="lead pl-4 p-1">
                In this example, the square is made up of 4 vertices and 2 triangles.
                For convenience, I labled the vertices A,B,C,D.
                <br>
                Let's say that C is the origin of our graph such that:
            </p>
            <p class="lead pl-4 p-1">
                A = (0,1,0), B = (1,1,0), C = (0,0,0) and D = (1,0,0)
            </p>
            <p class="lead pl-4 p-1">
                There are 2 ways of representing these meshes in memory. The first is relatvely simple, just store
                an array of vertices, with every 3 vertices making up a triangle.
            </p>
            <pre class="lead  ml-4 mr-4 text-white bg-secondary rounded border border-dark"><code>
    vec3[] <var>vertices</var> = { 
        A, B, D,    // The first triangle
        A, D, C     // The second triangle
    }
        </code></pre>
            <p class="lead pl-4 p-1">
                However, you'll notice that using this method, we end up storing some vertices twice,
                and when you start creating larger 3D meshes, this problem get's exponentially worse.
                It would be better to store each vertex only once. The second way of storing a mesh solves
                this problem.
                <br>
                In the second method, we use 2 arrays. The first array is a list of all the vertices in the mesh,
                the second is a list of indices that represent the triangles of the array.
            </p>
            <pre class="lead ml-4 mr-4 text-white bg-secondary rounded border border-dark"><code>
    vec3[] <var>vertices</var> = { 
        A, B, C, D  // A list of the vertices with no duplicates
    }
    
    int[] <var>triangles</var> = {
        1, 2, 4,    // The first triangle
        1, 4, 3     // The second triangle
    }
        </code></pre>
            <p class="lead pl-4 p-1">
                One thing to note when creating 3D meshes, the direction in which you draw the triangles is important.
                All triangles must be wrapped in a clockwise direction, otherwise they will render inside out.
                The direction of the triangle is based on the order you store it in.
                <br>
                <br>
                So, { A, D, B } is backwards since it is wrapped counter-clockwise,
                instead, you want to store it as { A, B, D }.
                <br>
                <br>
                Also, as long as they are wrapped clockwise, the order doesn't matter,
                so { A, B, D } is equivilant to { D, A, B } since they are wrapped in the same directions.
            </p>
    
        </div>
        <hr class="my-4 border-white">
    </div>

    <!-- Matrix Transformations ******************************************************************************** -->
    <div class="container-fluid w-75 pl-4">
        <button class="display-4 bg-dark text-white border-0" data-toggle="collapse" href="#MatrixTransformations" role="button"
            aria-expanded="false" aria-controls="MatrixTransformations">
            Matrix Transformation
        </button>
        <div class="collapse" id="MatrixTransformations">
            <p class="lead pl-4 p-1">
                If you've taken a course in Linear Algebra, you've probably heard of matrix transformation. If you are
                like me, however, you probably wondered how these transformations could be useful. In graphics programming
                matrix transformations are absolutely essential to everything we do. 
                <br>
                In this section, I amnot going to go over how matrices or matrix transformations work. Instead, I will 
                simply explain how we use them in when writing code. If you'd like to see a bit more of the math behind it, 
                check out <a href="https://learnopengl.com/Getting-started/Transformations">Learn OpenGL</a>. He goes over the 
                basics of transformations and how they work. 
                <br>
                <br>
                There are 3 core matrices used in rendering: model matrix, view matrix, and projection matrix. Each of these
                matrices transforms points to their own respective spaces. The <u><b>model matrix</b></u> transforms from 
                local space to world space (<b>Local Space</b> refers to the mesh objects vertices origin). The 
                <u><b>view matrix</b></u> converts from world space to view space (<b>View space</b> refers to where the camera
                is poitioned in the world). The <u><b>projection matrix</b></u> converts the view space into clip space (<b>Clip space</b>
                is what the camera can actually see in the world). Finally, after all that is done, one more autmatic transformation
                is performed to convert clip space into actual screen space. 
                <br>
                <a href="https://learnopengl.com/img/getting-started/coordinate_systems.png">Here's</a> a good diagram of this
            </p>
        </div>
        <hr class="my-4 border-white">
    </div>

    <!-- Memory Buffers ******************************************************************************** -->
    <div class="container-fluid w-75 pl-4">
        <button class="display-4 bg-dark text-white border-0" data-toggle="collapse" href="#MemoryBuffer" role="button"
            aria-expanded="false" aria-controls="MemoryBuffer">
            Memory Buffers
        </button>
        <div class="collapse" id="MemoryBuffer">
            <p class="lead pl-4 p-1">
                In order to render objects using the GPU, we first have to get the mesh data
                to the GPU. In OpenGL, we do this using buffers. A <u><b>GPU buffer</b></u> is simply an array of bytes
                stored in the GPU memory for use in shader programs. Buffers can be used to store
                all sorts of data, but generally, we use it for storing vertex information. 
                This vertex info is going to be stored in an array of values on the GPU. The 
                most basic thing you need to store is just the position data of each vertex. 
                <br>
                <br>
                In the buffer below, you simply have a an array of floats, where every 3 floats
                represents a vertex. 
            </p>
            <img src="./images/Vertex Buffer.png" class="rounded ml-5 d-block">
            <p class="lead pl-4 p-1">    
                However, when rendering a mesh, you often need more than just the vertex positions
                but sometimes want to store other information as well. 
                For this reason, when we store vertices on the GPU, we also have the ability to store other
                data with each vertex. This data could be a color, a texture position (also known as a <u><b>UV</b></u>), a normal value (important
                for lighting), or any other data that can be represented as primitve data types with static size.
                <br>
                <br>
                Here's an example of the array when storing more data:
            </p>
            <img src="./images/Mesh Buffer.png" class="rounded ml-5 d-block" width="100%">
            <p class="lead pl-4 p-1">    
                <br>
                When creating these arrays, it's important to keep track of the stride
                of your vertex data. The <u><b>stride</b></u> is the distance from the start of one vertex to 
                the start of the next vertex. Since you might store different types of data (like floats
                or ints), the stride is simply the count of bytes your vertex takes up. In the example 
                above, the stride is 9 * sizeof(float) or 36 bytes (since a float is 4 bytes). 
                <br>
                <br>
                Now the question is, how do we access and use this vertex data? In the next section we will cover
                how to create shaders for running programs on the GPU itself. 
            </p>

        </div>
        <hr class="my-4 border-white">
    </div>

    <!-- Shaders ******************************************************************************** -->
    <div class="container-fluid w-75 pl-4">
        <button class="display-4 bg-dark text-white border-0" data-toggle="collapse" href="#Shaders" role="button"
            aria-expanded="false" aria-controls="Shaders">
            Shaders
        </button>
        <div class="collapse" id="Shaders">
            <p class="lead pl-4 p-1">
                Now that we have our Mesh, and we've moved it to the GPU, we have to actually render it
                using the GPU. <u><b>Shaders</b></u> are programs stored on the GPU that can be run in parallel for large 
                sets of data. This is what makes the GPU so efficient for rendering items on the screen. We could have 
                thousands of vertices on the screen at a any given time. If we were to render each of these vertices 
                one at it time, it would take forever to render even a single frame, let alone 60 frames each second. 
                The GPU, however, has potentially thousands of cores that can all run in parallel. However, while it has a 
                lot of cores, each of the cores is significantly smaller than a typical CPU core. As a result, programs 
                run on the GPU are limited in size, and should primarily be used for performin mathmatical operations with as 
                few branches as possible. 
                <br>
                <br>
                There are six stages to the render pipeline that all run in a linear sequence:
                <br>
            </p>
            <h5 class="display-5 pl-5"><u ><b>Vertex Shader</b></u> -> Shape Assembly -> <u><b>Geometry Shader</b></u> -> 
                Tests and Blending -> <u><b>Fragment Shader</b></u> -> Rasterization </h5>
            <p class="lead pl-4 p-1"> 
                For most graphics programmers, we only really care about the Vertex Shader and the Fragment Shader
                stages of the pipeline, everything else is done automatically for us (though occasionally we may modify 
                the geometry shader, but I won't be going over that). 
                <br>
                Before we get into the specifics of the Vertex and Fragment Shader, lets go over a few general concepts 
                in he shader world: <u>input</u>, <u>output</u>, and <u>uniforms</u>. 
                <br>
                <br>
                <u>Inputs and Outputs:</u>
                Every stage of the shader process has a series of inputs and outputs. These inputs are the outputs created 
                after the previous stage of the render pipeline completed. In general, you can think of the render pipeline 
                as being a conveyer with a bunch of machines that moves the data along from one machine to another.
                Each of these machines takes in the data and transform it, until at the very end you have an image that 
                can be drawn to the screen. So, the input of one machine is the output of another.  
                <br>
                <br>
                <u>Uniforms:</u>
                When writing shaders, there is often some data that will be the same for every vertex in a mesh. 
                These are called uniforms. Uniforms can be used for all sorts of things. For example, you may want to
                color your whole object a single color. Rather than store a color value on every vertex, you can store one 
                uniform color, and use that on each vertex in the shader. Uniforms are used all over the place, because 
                often an object, while made up of many vertices, has object-wide properties that we don't want to store
                in every vertex. 

            </p>
            <h5 class="display-5 pl-3 text-white u">Vertex Shader</h5>
            <p class="lead pl-4 p-1">
                The Vertex Shader is the first stage of the render pipeline and run over every vertex in your mesh. 
                Since the vertex shader is the first stage of the pipeline it's input is provided from the CPU in the
                form of a vertex buffer. The primary output of the vertex shader is the screen-view position of the 
                vertex (the normalized (x,y,z) position in relation to the OpenGL window also known as normalized
                device coordinates).
                
            </p>
        </div>
    </div>

    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js"
        integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo"
        crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js"
        integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49"
        crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js"
        integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy"
        crossorigin="anonymous"></script>
</body>

</html>